<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Java基础, Adbo~Blog">
    <meta name="description" content="java基础">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Java基础 | Adbo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Adbo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-at" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Adbo</div>
        <div class="logo-desc">
            
            沉淀、分享、成长，让自己和他人都能有所收获
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-at"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://adbo.gitee.io/javaify" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://adbo.gitee.io/javaify" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/cover/iy0t2wdk.bmp')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java基础</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JAVA基础/">
                                <span class="chip bg-color">JAVA基础</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/review/" class="post-category">
                                review
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-08-01
                </div>
                

                

                

                
				
                
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS实现原理："><a href="#AQS实现原理：" class="headerlink" title="AQS实现原理："></a>AQS实现原理：</h3><ul>
<li>CountDownLatch、CyclicBarriar、Semaphore信号量、ReentrantLock、ReentrantReadWriteLock读写锁底层都有Sync类继承AQS类，都属于AQS框架。</li>
<li>AQS中 维护了一个volatile int state（代表共享资源）和一个FIFO双向等待CLH队列（多线程争用资源被阻塞时会进入此队列）。</li>
<li>另外state的操作都是通过CAS来保证其并发修改的安全性。</li>
<li>这里volatile能够保证多线程下的可见性，当state=1则代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个FIFO的等待队列中，比列会被UNSAFE.park()操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。</li>
<li>当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点，使其再次尝试获取同步状态。</li>
</ul>
<h3 id="加锁和挂起线程流程："><a href="#加锁和挂起线程流程：" class="headerlink" title="加锁和挂起线程流程："></a>加锁和挂起线程流程：</h3><p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/642.png" alt></p>
<ol>
<li><p>首先调用nonfairTryAcquire()获取<code>state</code>的值。如果为0，利用<code>CAS</code>尝试抢占锁compareAndSetState(0, 1)，且设置对象独占锁线程为当前线程setExclusiveOwnerThread(Thread.currentThread())；如果不为0则说明当前对象的锁已经被其他线程所占有，接着判断占有锁的线程是否为当前线程，如果是则累加<code>state</code>值。获取锁成功。</p>
</li>
<li><p>如果获取锁失败：首先执行<code>addWaiter(Node.EXCLUSIVE)</code>，加入到一个<code>FIFO</code>   CLH等待队列中。<code>addWaiter()</code>方法执行完后，会返回当前线程创建的节点信息。继续往后执行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>逻辑。<code>acquireQueued()</code>这个方法会先判断当前传入的<code>Node</code>对应的前置节点是否为<code>head</code>，如果是则尝试加锁。加锁成功过则将当前节点设置为<code>head</code>节点，然后空置之前的<code>head</code>节点，方便后续被垃圾回收掉。如果加锁失败或者<code>Node</code>的前置节点不是<code>head</code>节点，就会通过<code>shouldParkAfterFailedAcquire</code>方法 将前一个节点的<code>waitStatus</code>变为了<code>SIGNAL=-1</code>，最后执行<code>parkAndChecknIterrupt</code>方法，调用<code>LockSupport.park()</code>挂起当前线程，等着其他线程释放锁来唤醒它。</p>
</li>
</ol>
<h3 id="释放锁和唤醒线程流程："><a href="#释放锁和唤醒线程流程：" class="headerlink" title="释放锁和唤醒线程流程："></a>释放锁和唤醒线程流程：</h3><ol>
<li>首先是拥有锁的线程释放锁，释放锁后会唤醒<code>head</code>节点的后置节点。</li>
<li>首先会执行<code>tryRelease()</code>方法，执行完<code>ReentrantLock.tryRelease()</code>后，<code>state</code>被设置成0，Lock对象的独占锁被设置为null。如果<code>tryRelease</code>执行成功，则继续判断<code>head</code>节点的<code>waitStatus</code>是否为0，就会执行<code>unparkSuccessor()</code>方法来唤醒<code>head</code>的后置节点。<code>unparkSuccessor()</code>主要是将<code>head</code>节点的<code>waitStatus</code>设置为0，然后解除<code>head</code>节点<code>next</code>的指向，使<code>head</code>节点空置，等待着被垃圾回收。然后唤醒的节点就可以执行加锁流程了。</li>
</ol>
<hr>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ul>
<li>CAS，Compare And Swap，即比较和交换。</li>
<li>在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。</li>
<li>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。<ul>
<li>循环时间太长：如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。Java 8 推出了一个新的类，LongAdder，他就是尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能.</li>
<li>只能保证一个共享变量原子操作：看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。</li>
<li>ABA问题：对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="JMM-内存模型"><a href="#JMM-内存模型" class="headerlink" title="JMM(内存模型)"></a>JMM(内存模型)</h2><ul>
<li>Java采用内存共享的模式来实现线程之间的通信。</li>
<li>并发编程模式中，势必会遇到三个概念：<ul>
<li>原子性：一个操作或者多个操作要么全部执行要么全部不执行；</li>
<li>可见性：当多个线程同时访问一个共享变量时，如果其中某个线程更改了该共享变量，其他线程应该可以立刻看到这个改变；</li>
<li>有序性：程序的执行要按照代码的先后顺序执行；</li>
</ul>
</li>
</ul>
<hr>
<h2 id="DCL（中卫双重检查锁定）"><a href="#DCL（中卫双重检查锁定）" class="headerlink" title="DCL（中卫双重检查锁定）"></a>DCL（中卫双重检查锁定）</h2><pre><code>public class Singleton {
    // 通过volatile关键字来确保创建对象的三个步骤的指令不重排
    private volatile static Singleton singleton;

    private Singleton(){}

    public static Singleton getInstance(){
        if(singleton == null){
            synchronized (Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}</code></pre><hr>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li><p>在JMM（内存模型）中，线程之间的通信采用共享内存来实现的。</p>
</li>
<li><p>volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</p>
</li>
<li><p>实现volatile的内存语义JMM会限制重排序，其重排序规则如下：</p>
<ul>
<li>如果当前为volatile读时，后面的操作不能重排序。（这个操作确保volatile读之后的操作不会被编译器重排序到volatile读之前）；</li>
<li>如果当前为volatile写时，前面的操作不能重排序。（这个操作确保volatile写之前的操作不会被编译器重排序到volatile写之后）；</li>
<li>如果当前为volatile写时，紧接操作为volatile读时，不能重排序。</li>
</ul>
</li>
<li><p>volatile的底层是通过插入内存屏障实现的。</p>
<ul>
<li>在每一个volatile写操作前面插入一个StoreStore屏障</li>
<li>在每一个volatile写操作后面插入一个StoreLoad屏障</li>
<li>在每一个volatile读操作后面插入一个LoadLoad屏障</li>
<li>在每一个volatile读操作后面插入一个LoadStore屏障</li>
</ul>
<ol>
<li>StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</li>
<li>StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。</li>
<li>LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</li>
<li>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</li>
</ol>
</li>
<li><p>volatile可以保证可见性，对一个volatile的读，总可以看到对这个变量最终的写；</p>
</li>
<li><p>volatile不可以保证原子性，volatile对单个读/写具有原子性（32位Long、Double），但是复合操作除外，例如i++;</p>
</li>
<li><p>volatile可以保证有序性，JVM底层采用“内存屏障”来实现。</p>
</li>
<li><p>volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，volatile 是不负责解决这个问题的，也就是不负责解决原子性问题！原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。</p>
</li>
<li><p>对一个变量加了 volatile 关键字修饰之后，只要一个线程修改了这个变量的值，立马强制刷回主内存。接着强制过期其他线程的本地工作内存中的缓存，最后其他线程读取变量值的时候，强制重新从主内存来加载最新的值！</p>
</li>
</ul>
<hr>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul>
<li><p>普通同步方法，锁是当前实例对象；静态同步方法，锁是当前类的class对象；同步代码块，锁是括号里面的对象。</p>
</li>
<li><p>同步代码块：同步代码块是使用monitorenter和monitorexit指令实现的。monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。</p>
</li>
<li><p>同步方法：在Class文件的方法表中将该方法的accessflags字段中的synchronized标志位置1，表示该方法是同步方法，并使用调用该方法的对象或该方法所属的Class在JVM的内部对象做为锁对象。</p>
</li>
<li><p>Java对象头和monitor是实现synchronized的基础，synchronized用的锁是存在Java对象头里的。对象头包含哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID等等。</p>
</li>
<li><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
</li>
<li><p>锁消除：JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。例如方法中定义的局部变量没有逃逸出方法之外，可以加锁操作消除。</p>
</li>
<li><p>锁粗化：如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。锁粗化概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。例如一个for不断枷锁解锁，可以把锁放到for循环外。</p>
</li>
<li><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁只可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
</li>
<li><p>自旋锁：就是让该线程等待一段时间，不断循环去尝试获取锁。</p>
</li>
<li><p>自适应自旋锁：自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少。</p>
</li>
<li><p>对象头的Mark Word结构图<br>  <img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/a6e378ec.bmp" alt></p>
</li>
<li><p>偏向锁<br>  <img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/yaiopcog.bmp" alt="偏向锁的获取和释放流程"></p>
<ul>
<li><p>获取锁</p>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，执行同步代码块；</li>
<li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，执行同步代码块；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞的线程继续往下执行同步代码块；</li>
</ol>
</li>
<li><p>释放锁：偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</p>
<ol>
<li>暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态。</li>
</ol>
</li>
</ul>
</li>
<li><p>轻量级锁</p>
<p>  <img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/uta8xosj.bmp" alt="轻量级锁的获取和释放过程"></p>
<ul>
<li><p>获取锁</p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步代码块；</li>
<li>否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。</li>
</ol>
</li>
<li><p>释放锁</p>
<ol>
<li>取出在获取轻量级锁保存在栈中的数据；</li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
</li>
</ul>
</li>
<li><p>重量级锁：重量级锁通过对象内部的监视器（monitor）实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
</li>
</ul>
<hr>
<h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p>as-if-serial语义的意思是，所有的操作均可以为了优化而被重排序，但是你必须要保证重排序后执行的结果不能被改变，编译器、runtime、处理器都必须遵守as-if-serial语义。注意as-if-serial只保证单线程环境，多线程环境下无效。</p>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ul>
<hr>
<h2 id="ThreadLoacal"><a href="#ThreadLoacal" class="headerlink" title="ThreadLoacal"></a>ThreadLoacal</h2><p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/y8gischv.bmp" alt></p>
<ul>
<li>ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。（ThreadLocal在多线程下，每个线程对共享变量都会创建一份变量副本去操作，不会影响其他线程的变量副本）</li>
<li>ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</li>
<li>ThreadLocal为什么会内存泄漏？每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系。由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。那么要怎么避免这个问题呢？在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。</li>
</ul>
<p>个人术语：</p>
<ul>
<li>ThreadLocal在多线程下，每个线程对共享变量都会创建一份变量副本去操作，不会影响其他线程的变量副本。</li>
<li>ThreadLocal内部有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键。ThreadLocalMap是以key/value的形式存在的，key为当前ThreadLocal对象，value则是对应线程的变量副本。</li>
<li>key为ThreadLocal实例，它为一个弱引用，弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为变量副本还与当前线程存在一个强引用关系，如果这个线程对象不会销毁那么这个强引用关系则会一直存在，可能出现内存泄漏情况。在ThreadLocalMap中的set/get方法中，当key == null的情况，会对value设置为null，有利于GC回收。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。</li>
</ul>
<hr>
<h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程"></a>什么是线程和进程</h2><ul>
<li>进程：进程是程序的一次执行过程，是系统运行程序的基本单位。当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li>
<li>线程：。一个进程在其执行的过程中可以产生多个线程。多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</li>
</ul>
<hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</p>
<hr>
<h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。</p>
<h3 id="新建状态（NEW）"><a href="#新建状态（NEW）" class="headerlink" title="新建状态（NEW）"></a>新建状态（NEW）</h3><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</p>
<h3 id="就绪状态（RUNNABLE）"><a href="#就绪状态（RUNNABLE）" class="headerlink" title="就绪状态（RUNNABLE）"></a>就绪状态（RUNNABLE）</h3><p>当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<h3 id="运行状态（RUNNING）"><a href="#运行状态（RUNNING）" class="headerlink" title="运行状态（RUNNING）"></a>运行状态（RUNNING）</h3><p>如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。</p>
<h3 id="阻塞状态（BLOCKED）"><a href="#阻塞状态（BLOCKED）" class="headerlink" title="阻塞状态（BLOCKED）"></a>阻塞状态（BLOCKED）</h3><p>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：等待阻塞（o.wait-&gt;等待对列），同步阻塞(lock-&gt;锁池)，其他阻塞(sleep/join)。</p>
<h3 id="线程死亡（DEAD）"><a href="#线程死亡（DEAD）" class="headerlink" title="线程死亡（DEAD）"></a>线程死亡（DEAD）</h3><p>线程结束后就是死亡状态。</p>
<hr>
<h2 id="start-与-run-区别"><a href="#start-与-run-区别" class="headerlink" title="start 与 run 区别"></a>start 与 run 区别</h2><p>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</p>
<p>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</p>
<p>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程（就是一个方法）。</p>
<hr>
<h2 id="sleep-方法和-wait-方法区别和共同点"><a href="#sleep-方法和-wait-方法区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点"></a>sleep() 方法和 wait() 方法区别和共同点</h2><ul>
<li><strong>两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。</strong></li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li><strong>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</strong></li>
</ul>
<hr>
<h2 id="线程池的主要参数"><a href="#线程池的主要参数" class="headerlink" title="线程池的主要参数"></a>线程池的主要参数</h2><ul>
<li>corePoolSize（线程池核心线程大小）：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会 被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。</li>
<li>maximumPoolSize（线程池最大线程数量）：一个任务被提交到线程池后，首先会缓存到工作队列（后面会介绍）中，如果工作队列满了，则会创建一个新线程，然后从工作队列中的取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize来指定。</li>
<li>keepAliveTime（空闲线程存活时间）：一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定</li>
<li>unit（空间线程存活时间单位）：keepAliveTime的计量单位</li>
<li>workQueue（工作队列）：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：<ul>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</li>
<li>LinkedBlockingQuene：基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</li>
<li>SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</li>
<li>PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</li>
</ul>
</li>
<li>threadFactory（线程工厂）：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>
<li>handler（拒绝策略）：当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：<ul>
<li>CallerRunsPolicy：该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。</li>
<li>AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。</li>
<li>DiscardPolicy：该策略下，直接丢弃任务，什么都不做。</li>
<li>DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</li>
</ul>
</li>
</ul>
<p>个人术语：</p>
<ul>
<li>corePoolSize（线程池核心线程大小）：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会 被销毁。</li>
<li>maximumPoolSize（线程池最大线程数量）：最大线程数量。一个任务被提交到线程池后，首先会缓存到工作队列中，如果工作队列满了，则会创建一个新线程来处理最早的一个任务。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制。</li>
<li>keepAliveTime（空闲线程存活时间）：一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁</li>
<li>unit（空间线程存活时间单位）：空闲线程存活时间的计量单位</li>
<li>threadFactory（线程工厂）：创建一个新线程时使用的工厂，可以用来设定线程名等</li>
<li>workQueue（工作队列）：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：<ul>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</li>
<li>LinkedBlockingQuene：基于链表的无界阻塞队列，按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</li>
<li>SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</li>
<li>PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</li>
</ul>
</li>
<li>handler（拒绝策略）：当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：<ul>
<li>CallerRunsPolicy：该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。<ul>
<li>AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。</li>
<li>DiscardPolicy：该策略下，直接丢弃任务，什么都不做。</li>
<li>DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><ul>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li>
<li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li>
<li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换。</li>
</ul>
<hr>
<h2 id="线程池为什么要使用阻塞队列而不使用非阻塞队列"><a href="#线程池为什么要使用阻塞队列而不使用非阻塞队列" class="headerlink" title="线程池为什么要使用阻塞队列而不使用非阻塞队列"></a>线程池为什么要使用阻塞队列而不使用非阻塞队列</h2><ul>
<li>因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换。</li>
<li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。</li>
<li>使得在线程不至于一直占用cpu资源。</li>
</ul>
<hr>
<h2 id="如何配置线程池"><a href="#如何配置线程池" class="headerlink" title="如何配置线程池"></a>如何配置线程池</h2><ul>
<li>CPU密集型任务：尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。</li>
<li>IO密集型任务：可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。</li>
</ul>
<hr>
<h2 id="线程池的execute-和submit-方法"><a href="#线程池的execute-和submit-方法" class="headerlink" title="线程池的execute()和submit()方法"></a>线程池的execute()和submit()方法</h2><ul>
<li>execute()，执行一个任务，没有返回值。</li>
<li>submit()，提交一个线程任务，有返回值。submit(Callable<t> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。</t></li>
</ul>
<hr>
<h2 id="获取-Class-对象的-3-种方法"><a href="#获取-Class-对象的-3-种方法" class="headerlink" title="获取 Class 对象的 3 种方法"></a>获取 Class 对象的 3 种方法</h2><h3 id="调用某个对象的-getClass-方法"><a href="#调用某个对象的-getClass-方法" class="headerlink" title="调用某个对象的 getClass()方法"></a>调用某个对象的 getClass()方法</h3><pre><code>Person p = new Person();
Class clazz = p.getClass();</code></pre><h3 id="调用某个类的-class-属性来获取该类对应的-Class-对象"><a href="#调用某个类的-class-属性来获取该类对应的-Class-对象" class="headerlink" title="调用某个类的 class 属性来获取该类对应的 Class 对象"></a>调用某个类的 class 属性来获取该类对应的 Class 对象</h3><pre><code>Class clazz = Person.class;</code></pre><h3 id="使用-Class-类中的-forName-静态方法-最安全-性能最好"><a href="#使用-Class-类中的-forName-静态方法-最安全-性能最好" class="headerlink" title="使用 Class 类中的 forName()静态方法(最安全/性能最好)"></a>使用 Class 类中的 forName()静态方法(最安全/性能最好)</h3><pre><code>Class clazz=Class.forName(&quot;类的全路径&quot;); (最常用)</code></pre><hr>
<h2 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h2><pre><code>//获取 Person 类的 Class 对象
 Class clazz=Class.forName(&quot;reflection.Person&quot;);
 //使用.newInstane 方法创建对象
 Person p=(Person) clazz.newInstance();
//获取构造方法并创建对象
 Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class);
 //创建对象并设置属性
 Person p1=(Person) c.newInstance(&quot;李四&quot;,&quot;男&quot;,20);</code></pre><h3 id="Class-对象的-newInstance"><a href="#Class-对象的-newInstance" class="headerlink" title="Class 对象的 newInstance()"></a>Class 对象的 newInstance()</h3><p>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</p>
<h3 id="调用-Constructor-对象的-newInstance"><a href="#调用-Constructor-对象的-newInstance" class="headerlink" title="调用 Constructor 对象的 newInstance()"></a>调用 Constructor 对象的 newInstance()</h3><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p>
<hr>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/0001.png" alt></p>
<hr>
<h2 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h2><ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
<li>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</li>
</ul>
<hr>
<h2 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h2><ul>
<li>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
</li>
<li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</li>
<li>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</li>
</ul>
<hr>
<h2 id="CopyOnWriteArrayList的底层原理"><a href="#CopyOnWriteArrayList的底层原理" class="headerlink" title="CopyOnWriteArrayList的底层原理"></a>CopyOnWriteArrayList的底层原理</h2><ul>
<li>CopyOnWriteArrayList是线程安全的，写操作的时候会加锁，防止出现并发写入丢失数据的问题</li>
<li>CopyOnWriteArrayList底层也是数组实现的，在添加元素的时候，会复制一个新的数组，写操作在新数组上进行，读操作在原数组经行，写操作结束之后会把原数组指向新数组</li>
<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>
</ul>
<hr>
<h2 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h2><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<hr>
<h2 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h2><p>当把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p>
<hr>
<h2 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h2><p>为了能让 HashMap 存取高效，尽量减少hash冲突，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。</p>
<hr>
<h2 id="HashMap-与-HashTable-的区别"><a href="#HashMap-与-HashTable-的区别" class="headerlink" title="HashMap 与 HashTable 的区别"></a>HashMap 与 HashTable 的区别</h2><ul>
<li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li>
<li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li>
<li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>
<li>初始容量大小和每次扩充容量大小的不同 ：创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小.</li>
<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ul>
<hr>
<h2 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a>HashMap的put方法的具体流程</h2><p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/0010.png" alt="putVal方法执行流程图"></p>
<ol>
<li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</li>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</li>
<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</li>
<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li>
</ol>
<hr>
<h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式：<ul>
<li>在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><ol>
<li>ConcurrentHashMap在JDK1.7时是按照分段锁Segment和HashEntry实现线程安全的。每个ConcurrentHashMap里面包含有一个Segment数组，Segment数组里面包含有HashEntry数组，hashEntry是一个链表结构的元素。当对某个 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</li>
<li>ConcurrentHashMap在JDK1.8时取消了Segment分段锁，采用Node数组和CAS和synchronized来保证线程安全。synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</li>
</ol>
<hr>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><strong>IoC又叫控制反转，是一种设计思想。IoC的意思就是将原本在程序中手动创建对象的控制权，交给Spring框架来管理。IoC容器实际上就是个Map，以key，value的形式存在，map中存放的就是各种对象。IoC容器解决了各种对象之前复杂的依赖关系，只要加个注解引用就可以。</strong></p>
<hr>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><strong>AOP又叫面向切面编程，将那些与业务无关的公共调用的逻辑（如事务处理，日志管理，权限管理等）封装起来，减少代码的冗余度，也降低模块间的耦合度。Spring AOP是基于动态代理的。当被代理的对象，实现了某个接口，那么就会使用JDK Proxy，否则将会使用Cglib，这个时候Cglib会生成一个被代理对象的子类来代理。</strong></p>
<hr>
<h2 id="Spring-AOP-和-AspectJ-AOP-区别"><a href="#Spring-AOP-和-AspectJ-AOP-区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 区别"></a>Spring AOP 和 AspectJ AOP 区别</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多</strong>。</p>
<hr>
<h2 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h2><ol>
<li>客户端的所有请求都交给前端控制器DispatcherServlet来处理，DispatcherServlet会负责调用系统的其他模块来真正处理用户的请求；</li>
<li>DispatcherServlet收到请求后，将根据请求的信息（包括URL、请求参数等）以及映射处理器HandlerMapping的配置找到处理该请求的处理器；</li>
<li>在这个地方Spring会通过适配器处理器HandlerAdapter对该处理器进行封装；</li>
<li>处理器完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet；</li>
<li>DispatcherServlet还要借助视图解析器ViewResolver完成从逻辑视图到真实视图对象的解析工作；</li>
<li>当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。</li>
</ol>
<hr>
<h2 id="spring事务失效场景"><a href="#spring事务失效场景" class="headerlink" title="spring事务失效场景"></a>spring事务失效场景</h2><h3 id="数据库引擎不支持事务"><a href="#数据库引擎不支持事务" class="headerlink" title="数据库引擎不支持事务"></a>数据库引擎不支持事务</h3><p>MySQL 用的不是 InnoDB 引擎，而是用的 MyISAM 存储引擎</p>
<h3 id="事务方法未被-Spring-容器管理"><a href="#事务方法未被-Spring-容器管理" class="headerlink" title="事务方法未被 Spring 容器管理"></a>事务方法未被 Spring 容器管理</h3><p>如果事务方法所在的类没有加载到 Spring IOC 容器中，也就是说，事务方法所在的类没有被 Spring 容器管理，则Spring事务会失效。</p>
<p>例如：你的方法所在类没有加@Component或者@Service注解。</p>
<h3 id="方法没有被-public-修饰"><a href="#方法没有被-public-修饰" class="headerlink" title="方法没有被 public 修饰"></a>方法没有被 public 修饰</h3><p>如果事务所在的方法没有被 public 修饰，此时 Spring 的事务也会失效。</p>
<h3 id="同一类中方法之间直接的调用"><a href="#同一类中方法之间直接的调用" class="headerlink" title="同一类中方法之间直接的调用"></a>同一类中方法之间直接的调用</h3><p>如果同一个类中有两个方法分别为 A 和 B，方法 A 没有添加事务注解，而方法 B 添加了 @Transactional 事务注解，此时方法 A 直接调用方法 B，则方法 B 的事务会失效。</p>
<p>因为声明式事务管理（@Transactional）是建立在 AOP 动态代理之上的。其本质是对方法执行前后进行拦截，然后在目标方法开始执行之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。同一类内方法之间的直接调用是不走代理的，这样就无法进行功能的增强处理，所以事务不起作用。</p>
<h3 id="事务传播类型不支持事务"><a href="#事务传播类型不支持事务" class="headerlink" title="事务传播类型不支持事务"></a>事务传播类型不支持事务</h3><p>如果方法的事务传播类型为不支持事务的传播类型，则该方法的事务在 Spring 中会失效。<br>例如： A 方法的事务传播类型为 NOT_SUPPORTED，不支持事务，此时用带事务的方法 B 去调用 A 方法，则 A 方法的事务失效。</p>
<h3 id="进行异常捕捉却没有抛出"><a href="#进行异常捕捉却没有抛出" class="headerlink" title="进行异常捕捉却没有抛出"></a>进行异常捕捉却没有抛出</h3><p>比如对某一个新增数据代码段进行 try catch 异常，而 catch 里没有向外抛出异常，此时 spring 事务无法回滚。</p>
<h3 id="错误的标注异常类型"><a href="#错误的标注异常类型" class="headerlink" title="错误的标注异常类型"></a>错误的标注异常类型</h3><p>如果在 @Transactional 注解中标注的异常类型不是我们抛出的异常类型，则Spring事务的回滚会失效。<br>例如： Spring 中默认回滚的异常类型为 RuntimeException，如果此时你抛出的异常是 Exception，那么Spring 事务中无法捕获到 Exception 异常，则事务回滚会失效。</p>
<h3 id="开启多线程"><a href="#开启多线程" class="headerlink" title="开启多线程"></a>开启多线程</h3><p>开启一个线程去执行数据库操作，多线程内的方法将不被 spring 事务控制。<br>例如：一个带事务的方法 A 中开启线程去执行同类中的一个 insert 方法，即使这个操作失败了，也不会回滚 A 中的其他数据库操作。</p>
<hr>
<h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>@PostConstruct注解的方法在项目启动的时候执行这个方法，也可以理解为在spring容器启动的时候执行，可作为一些数据的常规化加载，比如初始化成员变量之类的。</p>
<p>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct</p>
<hr>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h3><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p>声明式事务又分为两种：</p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h3 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h3><p>支持当前事务的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p>不支持当前事务的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 如果当前存在事务，则把当前事务挂起,创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 如果当前存在事务，则把当前事务挂起,以非事务方式运行。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p>其他情况：</p>
<ul>
<li>ransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<hr>
<h2 id="spring-boot自动装配"><a href="#spring-boot自动装配" class="headerlink" title="spring boot自动装配"></a>spring boot自动装配</h2><p>Spring Boot启动类里面有个@SpringBootApplication注解，这个注解是@Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。</p>
<p>@EnableAutoConfiguration注解里面@Import({AutoConfigurationImportSelector.class}) //加载自动装配类 xxxAutoconfiguration。AutoConfigurationImportSelector 类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</p>
<p>不光是这个依赖下的META-INF/spring.factories被读取到，所有 Spring Boot Starter 下的META-INF/spring.factories都会被读取到。但需要过滤，@ConditionalOnXXX。</p>
<p>Spring Boot 通过@EnableAutoConfiguration开启自动装配，通过 SpringFactoriesLoader 最终加载META-INF/spring.factories中的自动配置类实现自动装配，自动配置类其实就是通过@Conditional按需加载的配置类，想要其生效必须引入spring-boot-starter-xxx包实现起步依赖</p>
<hr>
<h2 id="二叉树的遍历规则"><a href="#二叉树的遍历规则" class="headerlink" title="二叉树的遍历规则"></a>二叉树的遍历规则</h2><p>树的遍历顺序大体分为三种：前序遍历（先根遍历、先序遍历），中序遍历（中根遍历），后序遍历（后根遍历）。</p>
<p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/qiiji4ye.bmp" alt></p>
<ul>
<li><p>前序遍历的规则：</p>
<ol>
<li><p>访问根节点</p>
</li>
<li><p>前序遍历左子树</p>
</li>
<li><p>前序遍历右子树</p>
<p>前序遍历的输出结果：ABDECF</p>
</li>
</ol>
</li>
<li><p>中序遍历的规则：</p>
<ol>
<li><p>中序遍历左子树</p>
</li>
<li><p>访问根节点</p>
</li>
<li><p>中序遍历右子树</p>
<p>中序遍历的输出结果：DBEAFC</p>
</li>
</ol>
</li>
<li><p>后序遍历二叉树的规则：</p>
<ol>
<li><p>后序遍历左子树</p>
</li>
<li><p>后序遍历右子树</p>
</li>
<li><p>访问根节点</p>
<p>后序遍历的输出顺序：DEBFCA</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>举例说明：要排序数组：int[] arr={6,3,8,2,9,1};   </p>
<p>第一趟排序：</p>
<p>　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1</p>
<p>　　　　第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1</p>
<p>　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1</p>
<p>　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1</p>
<p>　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9</p>
<p>　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9</p>
<p>第二趟排序：</p>
<p>　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9</p>
<p>　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9</p>
<p>　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9</p>
<p>　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9</p>
<p>　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9</p>
<p>第三趟排序：</p>
<p>　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9</p>
<p>　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9</p>
<p>　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9</p>
<p>　　　　第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9</p>
<p>第四趟排序：</p>
<p>　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9</p>
<p>　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9</p>
<p>　　　　第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9</p>
<p>第五趟排序：</p>
<p>　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9</p>
<p>　　　　第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9</p>
<p>最终结果：1  2  3  6  8  9</p>
<pre><code>for(int i=0;i&lt;arr.length-1;i++){//外层循环控制排序趟数
　　for(int j=0;j&lt;arr.length-1-i;j++){//内层循环控制每一趟排序多少次
　　　　if(arr[j]&gt;arr[j+1]){
　　　　　　int temp=arr[j];
　　　　　　arr[j]=arr[j+1];
　　　　　　arr[j+1]=temp;
　　　　}
　　}
} </code></pre><hr>
<h2 id="StringBuffer-和-StringBuilder-的区别"><a href="#StringBuffer-和-StringBuilder-的区别" class="headerlink" title="StringBuffer 和 StringBuilder 的区别"></a>StringBuffer 和 StringBuilder 的区别</h2><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<hr>
<h2 id="与-equals-重要"><a href="#与-equals-重要" class="headerlink" title="== 与 equals(重要)"></a>== 与 equals(重要)</h2><ul>
<li>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</li>
<li>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</li>
</ul>
<ol>
<li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ol>
<pre><code>public class test1 {
    public static void main(String[] args) {
        String a = new String(&quot;ab&quot;); // a 为一个引用
        String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样
        String aa = &quot;ab&quot;; // 放在常量池中
        String bb = &quot;ab&quot;; // 从常量池中查找
        if (aa == bb) // true
            System.out.println(&quot;aa==bb&quot;);
        if (a == b) // false，非同一对象
            System.out.println(&quot;a==b&quot;);
        if (a.equals(b)) // true
            System.out.println(&quot;aEQb&quot;);
        if (42 == 42.0) { // true
            System.out.println(&quot;true&quot;);
        }
    }
}</code></pre><hr>
<h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><ol>
<li>Java 中 IO 流分为几种?</li>
</ol>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<ol start="2">
<li>Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</li>
</ol>
<ul>
<li><strong>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</strong></li>
<li><strong>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</strong></li>
</ul>
<p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/ep4ijzng.bmp" alt></p>
<p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/755xfuro.bmp" alt></p>
<hr>
<h2 id="BIO-NIO-AIO-区别"><a href="#BIO-NIO-AIO-区别" class="headerlink" title="BIO,NIO,AIO 区别"></a>BIO,NIO,AIO 区别</h2><ul>
<li>BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</li>
<li>NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型.</li>
<li>AIO (Asynchronous I/O): AIO 是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
<hr>
<h2 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h2><p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/20180904143958577.png" alt></p>
<p>区别如下：</p>
<ul>
<li><p>来源：lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</p>
</li>
<li><p>异常是否释放锁：synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</p>
</li>
<li><p>是否响应中断：lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断</p>
</li>
<li><p>是否知道获取锁：Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</p>
</li>
<li><p>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</p>
</li>
<li><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
</li>
<li><p>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度</p>
<pre><code>  //Condition定义了等待/通知两种类型的方法
  Lock lock=new ReentrantLock();
  Condition condition=lock.newCondition();
  ...
  condition.await();
  ...
  condition.signal();
  condition.signalAll();</code></pre></li>
</ul>
<hr>
<h2 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。</li>
<li>通过该类提供的方法来实现对隐藏信息的操作和访问。</li>
<li>隐藏对象的信息。</li>
<li>留出访问的对外接口。</li>
</ul>
<pre><code>public class Student implements Serializable {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</code></pre><p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/960a304e251f95ca446e530854b0ed3666095221.webp" alt></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法。当然，如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。</p>
<ul>
<li>只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。<br>​- 子类可以拥有父类的属性和方法。<br>​- 子类可以拥有自己的属性和方法。<br>​- 子类可以重写覆盖父类的方法。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态的体现形式</p>
<ul>
<li>继承</li>
<li>父类引用指向子类</li>
<li>重写</li>
</ul>
<pre><code>class MultiDemo {
    public static void main(String[] args) {
        // 多态的引用，就是向上转型
        Animals dog = new Dog();
        dog.eat();

        Animals cat = new Cat();
        cat.eat();

        // 如果要调用父类中没有的方法，则要向下转型
        Dog dogDown = (Dog)dog;
        dogDown.watchDoor();

    }
}
class Animals {
    public void eat(){
        System.out.println(&quot;动物吃饭！&quot;);
    }
}
class Dog extends Animals{
    public void eat(){
        System.out.println(&quot;狗在吃骨头！&quot;);
    }
    public void watchDoor(){
        System.out.println(&quot;狗看门！&quot;);
    }
}
class Cat extends Animals{
    public void eat(){
        System.out.println(&quot;猫在吃鱼！&quot;);
    }
}</code></pre><hr>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>short类型占16个字节；2位；</li>
<li>int类型占32个字节；4位；</li>
<li>long类型占64个字节；8位；</li>
<li>float类型占32个字节；4位；</li>
<li>double类型占64个字节；8位；</li>
<li>char类型占16个字节；2位；</li>
<li>boolean类型占8个字节；1位；</li>
<li>byte类型占8个字节；1位。</li>
</ul>
<hr>
<h2 id="JDBC编码"><a href="#JDBC编码" class="headerlink" title="JDBC编码"></a>JDBC编码</h2><pre><code>public static void main(String[] args) throws ClassNotFoundException, SQLException {
    //加载驱动
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  //固定写法 加载驱动
    //用户信息和URL
    //localhost:mysql默认端口号3306 我是由于改了mysql的端口号
    String url=&quot;jdbc:mysql://localhost:3307/user?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;;
    String username=&quot;root&quot;;
    String password=&quot;0000&quot;;//数据库密码
    //连接成功，数据库对象  Connection代表数据库
    Connection connection = DriverManager.getConnection(url, username, password);
    //执行SQL的对象 statement执行SQL的对象
    Statement statement=connection.createStatement();
    //执行SQL的对象去执行SQL，可能存在返回结果，查看返回结果
    String sql=&quot;SELECT * FROM tb_users&quot;;
    String sql2=&quot;INSERT INTO tb_users(sname,pwd)  VALUES(&#39;zhangsan&#39;,&#39;123&#39;)&quot;;
    int i = statement.executeUpdate(sql2);
    System.out.println(&quot;受影响行数&quot;+i);
    ResultSet resultSet = statement.executeQuery(sql);  // 返回的结果集
    while(resultSet.next()){
        //字段要和数据库的字段一致
        System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));
        System.out.println(&quot;sname=&quot;+resultSet.getObject(&quot;sname&quot;));
        System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;pwd&quot;));
        System.out.println(&quot;=====================================&quot;);
    }

    //释放连接
    resultSet.close();
    statement.close();
    connection.close();
}</code></pre><hr>
<h2 id="过滤器和拦截器"><a href="#过滤器和拦截器" class="headerlink" title="过滤器和拦截器"></a>过滤器和拦截器</h2><p>Filter过滤器是在Servlet规范定义的，是servlet容器支持的；而拦截器interceptor在spring容器内的，是spring框架支持的。</p>
<p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/2371394-20211108170054822-2098663925.png" alt></p>
<p>过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。过滤器包裹住servlet，servlet包裹住拦截器。</p>
<p>过滤器的触发时机是容器后，servlet之前，所以过滤器的doFilter(ServletRequest request, ServletResponse response, FilterChain chain)的入参是ServletRequest ，而不是httpservletrequest。因为过滤器是在httpservlet之前就起作用了。</p>
<p>拦截器preHandle：拦截器实现HandlerInterceptor 接口，控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>拦截器postHandle：控制器方法执行之后执行postHandle()</p>
<p>拦截器afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p>
<p><img src="/2020/08/01/2020-08-01-zhong-ji-yi-zhan/2371394-20211109111408221-407006331.png" alt></p>
<hr>
<h2 id="ZooKeeper的工作原理"><a href="#ZooKeeper的工作原理" class="headerlink" title="ZooKeeper的工作原理"></a>ZooKeeper的工作原理</h2><p>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</p>
<hr>
<h2 id="zookeeper提供了什么"><a href="#zookeeper提供了什么" class="headerlink" title="zookeeper提供了什么"></a>zookeeper提供了什么</h2><p>简单的说，zookeeper=文件系统+通知机制。</p>
<hr>
<h2 id="快速排除线上故障"><a href="#快速排除线上故障" class="headerlink" title="快速排除线上故障"></a>快速排除线上故障</h2><h3 id="CPU过高"><a href="#CPU过高" class="headerlink" title="CPU过高"></a>CPU过高</h3><p>当CPU过高的时候，接口性能会快速下降，同时监控也会开始报警。</p>
<ol>
<li>利用 top 命令查询CPU使用率最高的进程拿到PID</li>
<li>执行命令：printf “%x\n” PID ，将线程 PID 转化为 16 进制为tid:</li>
<li>执行命令 jstack PID | grep tid -A 30 找到线程堆栈，打印前后30行，可定位哪个类的哪一行代码</li>
</ol>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><ol>
<li>下载dump文件</li>
<li>Eclipse Memory Analyzer(MAT)解析dump文件</li>
<li>点击查看内存对象统计详情，定位到对象和对应引用</li>
<li>查看shallow heap与retained heap能发现生成了大量的Object, 无法释放</li>
</ol>

            </div>
            <hr>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://adbo.gitee.io" rel="external nofollow noreferrer">Adbo</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://adbo.gitee.io/2020/08/01/2020-08-01-zhong-ji-yi-zhan/">http://adbo.gitee.io/2020/08/01/2020-08-01-zhong-ji-yi-zhan/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://adbo.gitee.io" target="_blank">Adbo</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JAVA基础/">
                                    <span class="chip bg-color">JAVA基础</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">充点钱我更猛</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '9150c7c4b90b14e0cd58',
        clientSecret: '9666f231bec8dfe9335833e3684d57d2fcf8da6b',
        repo: 'gitalk',
        owner: 'adbbo',
        admin: "adbbo",
        id: '2020-08-01T11-23-46',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/08/12/2020-08-12-ce-lue-mo-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="工厂 + 策略模式">
                        
                        <span class="card-title">工厂 + 策略模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            工作中常用的工厂 + 策略模式，避免冗余的if
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/复习PLUS/" class="post-category">
                                    复习PLUS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/设计模式/">
                        <span class="chip bg-color">设计模式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/07/28/2020-07-28-tcp-udp/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="TCP&UDP">
                        
                        <span class="card-title">TCP&UDP</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            TCP&UDP
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/复习PLUS/" class="post-category">
                                    复习PLUS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TCP-UDP/">
                        <span class="chip bg-color">TCP&amp;UDP</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="http://adbo.gitee.io" target="_blank">Adbo</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/adbbo" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1309338083@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1309338083" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1309338083" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
