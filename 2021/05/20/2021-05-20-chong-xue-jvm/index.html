<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="JVM, Adbo~Blog">
    <meta name="description" content="JVM思路清晰版~">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>JVM | Adbo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Adbo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-at" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Adbo</div>
        <div class="logo-desc">
            
            沉淀、分享、成长，让自己和他人都能有所收获
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-at"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://adbo.gitee.io/javaify" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://adbo.gitee.io/javaify" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JVM</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JVM/">
                                <span class="chip bg-color">JVM</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/review/" class="post-category">
                                review
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-05-20
                </div>
                

                

                

                
				
                
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-Java-内存区域-运行时数据区"><a href="#1-Java-内存区域-运行时数据区" class="headerlink" title="1 Java 内存区域(运行时数据区)"></a>1 Java 内存区域(运行时数据区)</h2><h3 id="JDK-1-8之前："><a href="#JDK-1-8之前：" class="headerlink" title="JDK 1.8之前："></a>JDK 1.8之前：</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/hlwi08xk.bmp" alt></p>
<h3 id="JDK-1-8-："><a href="#JDK-1-8-：" class="headerlink" title="JDK 1.8 ："></a>JDK 1.8 ：</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/j141wm5o.bmp" alt></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li>
<li>程序计数器可以实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 </p>
<p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p>
<ul>
<li>StackOverFlowError： 当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。例如没完没了的递归（炸了吧）</li>
<li>OutOfMemoryError： 若 Java 虚拟机栈的内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p>Java 栈可类比数据结构中的栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。Java方法有两种返回方式：</p>
<ul>
<li>return 语句</li>
<li>抛出异常</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，底层是调用C/C++方法。 </p>
<p>本地方法栈也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p><strong>Java 堆是垃圾收集器管理的主要区域</strong>，因此也被称作GC堆。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/0md51ltn.bmp" alt></p>
<p><strong>eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</strong></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p><strong>方法区也被称为永久代。</strong> 相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<h4 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?"></a>为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?</h4><p>整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<p><strong>DK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/7p80rev4.bmp" alt></p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>线程私有的是JAVA 虚拟机栈、本地方法栈、程序计数器；线程共享的是堆和方法区。</li>
<li>Java 虚拟机栈：虚拟机栈中主要保存了局部变量，包含各种基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用（reference类型）。Java 虚拟机栈中主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。栈帧里面又主要包含了：局部变量表、操作数栈、动态链接、方法出口。Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</li>
<li>本地方法栈：本地方法栈和和虚拟机栈所发挥的作用非常相似。两者的区别在于：虚拟机栈执行的是JAVA方法，而本地方法栈调用的是nvtice方法，底层调用的是C/C++方法。也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</li>
<li>程序计数器：程序计数器实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域.</li>
<li>堆：堆存放的是对象实例，几乎所有的对象实例以及数组都在这里分配内存。堆是垃圾收集器管理的主要区域，因此也被称作GC堆。堆还可以细分为：新生代和老年代，再细致一点有：Eden空间、From Survivor、To Survivor空间等。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</li>
<li>方法区：方法区主要存储加载的类信息、常量、静态变量等。方法区也被称为永久代。在JDK 1.8 的时候，方法区被取代成元空间，元空间使用的是直接内存。因为方法区受jvm的大小配置限制，而元空间直接受机器的内存管理，永远不会得到java.lang.OutOfMemoryError。</li>
<li>运行时常量池：常量池是方法区的一部分，主要存放字面量和符号引用，会抛出 OutOfMemoryError 异常。DK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</li>
</ul>
<h2 id="2-Java对象的创建过程"><a href="#2-Java对象的创建过程" class="headerlink" title="2 Java对象的创建过程"></a>2 Java对象的创建过程</h2><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/1rfud9wf.bmp" alt></p>
<h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/y2du1php.bmp" alt></p>
<h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></init></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>类加载检查：虚拟机遇到一条new指令时，会先在常量池中定位是否有类的符号引用，并且检查这个类是否已经被加载过，如果没有被加载过，就先执行类的加载过程。</li>
<li>分配内存：当类加载检查完成后，对象所需的内存大小也就确定了。分配内存主要有两种方式：“指针碰撞” 和 “空闲列表” 。用哪种方式主要看内存的规整来决定。如果内存规整，也就是用指针碰撞的形式，如serial，parlnew垃圾收集器，回收算法是标志-整理和复制算法。如果内存不规整，用空闲列表的形式，如CMS垃圾收集器，回收算法是标志-清除。</li>
<li>初始化零值：这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。</li>
<li>设置对象头：主要把类的信息，hash码以及分代年龄等信息存放在对象头中。</li>
<li>执行init方法：把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ol>
<h2 id="3-类的加载过程"><a href="#3-类的加载过程" class="headerlink" title="3 类的加载过程"></a>3 类的加载过程</h2><p>类的加载过程为：加载、链接和初始化，其中链接可以细分为：验证、准备和解析。</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image-20200705082601441.png" alt></p>
<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ul>
<li>通过类的全限定名读取此类二进制字节流。</li>
<li>将字节流转化为方法区的运行时数据结构。</li>
<li>在堆内存中生成该类的 Class 对象，作为该类的访问入口。</li>
</ul>
<h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul>
<li>验证：确保被加载类的正确性。</li>
<li>准备：为类变量分配内存并设置默认初始值。</li>
<li>解析：将常量池内的符号引用转换为直接引用。(符号引用就是描述目标，直接引用就是指向目标的地址。举个例子来说，现在调用方法 hello，这个方法的地址是 1234567，那么 hello 就是符号引用，1234567 就是直接引用)</li>
</ul>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>执行类的初始化方法 clinit，执行内容包括静态变量初始化和静态块的执行。</p>
<h2 id="4-对象的访问定位两种方式"><a href="#4-对象的访问定位两种方式" class="headerlink" title="4 对象的访问定位两种方式"></a>4 对象的访问定位两种方式</h2><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种。</p>
<h3 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/dllw5s27.bmp" alt></p>
<p>如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/aqodd113.bmp" alt></p>
<p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Java程序通过栈上的 reference 数据来操作堆上的具体对象，访问对象有使用句柄和直接指针两种方式。</li>
<li>使用句柄：Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
<li>直接指针：reference 中存储的直接就是对象实列数据的地址，对象实例数据中包含了类型数据的具体地址信息。</li>
<li>优缺点：使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，reference 中存储的直接就是对象实列数据的地址，节省了一次指针定位的时间开销。</li>
</ol>
<h2 id="5-堆内存中对象的分配的基本策略"><a href="#5-堆内存中对象的分配的基本策略" class="headerlink" title="5 堆内存中对象的分配的基本策略"></a>5 堆内存中对象的分配的基本策略</h2><p>堆空间的基本结构：</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/al16mkpf.bmp" alt></p>
<p>eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p>
<p>另外，大对象和长期存活的对象会直接进入老年代。</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/40cpg52o.bmp" alt></p>
<h2 id="6-Minor-Gc和Full-GC区别"><a href="#6-Minor-Gc和Full-GC区别" class="headerlink" title="6 Minor Gc和Full GC区别"></a>6 Minor Gc和Full GC区别</h2><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<h3 id="新生代GC（Minor-GC）"><a href="#新生代GC（Minor-GC）" class="headerlink" title="新生代GC（Minor GC）"></a>新生代GC（Minor GC）</h3><p>指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</p>
<h3 id="老年代GC（Major-GC-Full-GC）"><a href="#老年代GC（Major-GC-Full-GC）" class="headerlink" title="老年代GC（Major GC/Full GC）"></a>老年代GC（Major GC/Full GC）</h3><p>指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</p>
<h2 id="7-判断对象是否死亡"><a href="#7-判断对象是否死亡" class="headerlink" title="7 判断对象是否死亡"></a>7 判断对象是否死亡</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p>
<ul>
<li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>
<li>缺点：无法解决循环引用问题</li>
</ul>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image.png" alt></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image1.png" alt></p>
<p>Java中可以作为GC Roots的对象：</p>
<ul>
<li>栈帧中的局部变量引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(Native方法)引用的对象</li>
</ul>
<p><a href="https://blog.csdn.net/summer_fish/article/details/115399628" target="_blank" rel="noopener">参考例子</a></p>
<h2 id="8-强引用-软引用-弱引用-虚引用"><a href="#8-强引用-软引用-弱引用-虚引用" class="headerlink" title="8 强引用,软引用,弱引用,虚引用"></a>8 强引用,软引用,弱引用,虚引用</h2><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<h3 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h3><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h3 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h3><p>如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h3><p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收的活动。</p>
<p>虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>
<h2 id="9-判断一个常量是废弃常量"><a href="#9-判断一个常量是废弃常量" class="headerlink" title="9 判断一个常量是废弃常量"></a>9 判断一个常量是废弃常量</h2><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>
<h2 id="10-判断一个类是无用的类"><a href="#10-判断一个类是无用的类" class="headerlink" title="10 判断一个类是无用的类"></a>10 判断一个类是无用的类</h2><ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="11-方法区与其他内存结构关系"><a href="#11-方法区与其他内存结构关系" class="headerlink" title="11 方法区与其他内存结构关系"></a>11 方法区与其他内存结构关系</h2><ul>
<li>Person：存放在元空间，也可以说方法区。</li>
<li>person：存放在Java栈的局部变量表中。</li>
<li>new Person()：存放在Java堆中。</li>
</ul>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image-20200708094747667.png" alt></p>
<h2 id="12-堆"><a href="#12-堆" class="headerlink" title="12 堆"></a>12 堆</h2><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/20210401230845268.png" alt></p>
<h3 id="默认新生代和老年代的占比"><a href="#默认新生代和老年代的占比" class="headerlink" title="默认新生代和老年代的占比"></a>默认新生代和老年代的占比</h3><p>默认 -XX:NewRatio=2，代表新生代占 1，老年代占 2，即新生代占整个堆的 1/3。</p>
<h3 id="默认-Eden-和-Survivor-的占比"><a href="#默认-Eden-和-Survivor-的占比" class="headerlink" title="默认 Eden 和 Survivor 的占比"></a>默认 Eden 和 Survivor 的占比</h3><p>默认 -xx:SurvivorRatio=8，代表 Eden 和 From Survivor，To Survivor 占比是 8：1：1。</p>
<h3 id="堆对象流转过程"><a href="#堆对象流转过程" class="headerlink" title="堆对象流转过程"></a>堆对象流转过程</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/20210401230851499.png" alt></p>
<ol>
<li>创建的对象优先在 Eden 区分配（较长的字符串，数组，大对象直接进老年代）。</li>
<li>如果发现 Eden 满了，会触发第一次GC，把还活着的对象拷贝到from区。而当Eden Space再次触发GC时，会扫描Eden Space和from，对这两个区进行垃圾回收，经过此次回收后依旧存活的对象，则直接复制到to区（如果对象的年龄已经达到老年的标准，则移动至老年代区），同时把这些对象的年龄+1。然后，清空Eden Space和from中的对象，此时的from是空的。最后，from和to进行互换，原from成为下一次GC时的to，原to成为下一次GC时的from。</li>
<li>部分对象会在from和to中来回进行交换复制，如果交换15次（由JVM参数MaxTenuringThreshold决定，默认15），最终依旧存活的对象就会移动至老年代。</li>
<li>当老年代内存不足时，会触发 Major GC 对老年代进行回收。</li>
</ol>
<h2 id="13-类文件结构"><a href="#13-类文件结构" class="headerlink" title="13 类文件结构"></a>13 类文件结构</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p>
<pre><code>ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}</code></pre><p>Class文件字节码结构组织示意图</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/n30hvpi9.bmp" alt></p>
<h2 id="14-双亲委派机制"><a href="#14-双亲委派机制" class="headerlink" title="14 双亲委派机制"></a>14 双亲委派机制</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li><p>启动类加载器属于虚拟机的一部分，是用 C++ 写的，看不到源码。</p>
<p>  启动类加载器：加载的是 jre/lib 目录下的核心库。</p>
</li>
<li><p>其他类加载器是用 Java 写的。</p>
<ul>
<li><p>扩展类加载器：加载的是 jre/lib/ext 目录下的扩展包。</p>
</li>
<li><p>应用类加载器：加载的是 我们自己的 Java 代码编译成的 Class 文件的目录（ClassPath）。</p>
</li>
<li><p>自定义类加载器。</p>
</li>
</ul>
</li>
</ul>
<h3 id="双亲委派机制的工作原理"><a href="#双亲委派机制的工作原理" class="headerlink" title="双亲委派机制的工作原理"></a>双亲委派机制的工作原理</h3><ol>
<li>当一个类加载器接收到类加载任务时，先查缓存里有没有，如果没有，将任务委托给它的父加载器去执行。</li>
<li>父加载器也做同样的事情，一层一层往上委托，直到最顶层的启动类加载器为止。</li>
<li>如果启动类加载器没有找到所需加载的类，便将此加载任务退回给下一级类加载器去执行，而下一级的类加载器也做同样的事情。</li>
<li>如果最底层类加载器仍然没有找到所需要的 class 文件，则抛出异常。</li>
</ol>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image-20200705105151258.png" alt></p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>避免类被重复加载 + 避免核心 API 被篡改。</p>
<p>如果没有双亲委托机制来确保类的全局唯一性，谁都可以编写一个 java.lang.String 类放在 classpath 下，那应用程序就乱套了。所以自定义一个与核心类库重名的类，会发现这个类可以被正常编译，但永远无法被加载运行。因为这个类不会被应用类加载器加载，而是被委托到顶层，被启动类加载器在核心类库中找到了。</p>
<h3 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="headerlink" title="如何破坏双亲委派模型"></a>如何破坏双亲委派模型</h3><p>自定义类加载器，重写 loadClass 方法。</p>
<h2 id="15-并发的可达性分析（三色标记）"><a href="#15-并发的可达性分析（三色标记）" class="headerlink" title="15 并发的可达性分析（三色标记）"></a>15 并发的可达性分析（三色标记）</h2><p>首先需要引入三种颜色：</p>
<ul>
<li>白色：对象没被 GC 访问过。若分析结束还是白色的对象，则代表不可达。</li>
<li>黑色：对象已经被 GC 访问过，且这个对象的所有引用都扫描过了，他是安全存活的。</li>
<li>灰色：对象已经被 GC 访问过，但这个对象上还存在没有被扫描过的引用。</li>
</ul>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image2.png" alt></p>
<p>并发标记阶段，会出现两种问题：</p>
<ul>
<li>把白色对象错标成了黑色对象（问题不大，只是产生了浮动垃圾，下次再清理）。</li>
<li>把黑色对象错标成白色对象（裂了啊，我的对象怎么不见了）。并发时，灰色对象的一个引用被切断，然后和已扫描过的黑色对象建立了引用关系。</li>
</ul>
<p>解决这个问题的方案有两个：增量更新和原始快照。</p>
<ul>
<li>增量更新（CMS）：当黑色对象和白色对象建立引用关系时，会记录下来黑色对象的引用，等到最终标记时，再将这些黑色对象作为根，再重新扫描。</li>
<li>原始快照（G1）：当灰色对象删除对白色对象的引用关系时，会记录下来白色对象的引用，再以这些白色对象作为根，再重新扫描。</li>
</ul>
<h2 id="16-垃圾收集算法"><a href="#16-垃圾收集算法" class="headerlink" title="16 垃圾收集算法"></a>16 垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/tpi6cpml.bmp" alt></p>
<p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><ul>
<li>存活对象较多的情况下比较高效（老年代）。</li>
</ul>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>使用内存少</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>效率低。扫描了整个空间两次。</li>
<li>会产生大量不连续的碎片，导致大对象无法在空闲列表找到可分配的空间。</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/dknyft70.bmp" alt></p>
<p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<h4 id="适用场合："><a href="#适用场合：" class="headerlink" title="适用场合："></a>适用场合：</h4><ul>
<li>存活对象较少的情况下比较高效（新生代）。</li>
<li>只扫描了整个空间一次（标记存活对象并复制移动）。</li>
</ul>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>效率高</li>
<li>内存规整</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>需要两倍的内存空间。</li>
<li>像老年代那种回收完还有大量的对象存活的区域，需要复制的对象将会有很多，效率会很低。</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/qish34yq.bmp" alt></p>
<p>首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
<ul>
<li>效率最低</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<h2 id="17-分为新生代和老年代的好处"><a href="#17-分为新生代和老年代的好处" class="headerlink" title="17 分为新生代和老年代的好处"></a>17 分为新生代和老年代的好处</h2><p>主要是为了提升GC效率。</p>
<h2 id="18-垃圾收集器"><a href="#18-垃圾收集器" class="headerlink" title="18 垃圾收集器"></a>18 垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/w2jtzc95.bmp" alt></p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image7.png" alt></p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p>
<p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/ngopf1fj.bmp" alt></p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image10.png" alt></p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器）配合工作。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器类似于ParNew 收集器。</p>
<p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/2tlrkyi5.bmp" alt></p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</p>
<p>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li>
</ul>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/yjdb4a3c.bmp" alt></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p>
<ul>
<li>对CPU资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
<p>由于 CMS 的并发标记和并发清除阶段，用户线程还在进行运行，所以也会不断产生垃圾，而 CMS 无法在当次收集中处理它们，只能等到下一次垃圾收集时再清理掉，这部分垃圾就称为浮动垃圾。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p>
<p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li>并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>
<li>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li>
</ul>
<p>G1收集器的运作大致分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/r0psxic5.bmp" alt></p>
<h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><ul>
<li>串行回收器：Serial、Serial Old。</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel Old。</li>
<li>并发回收器：CMS、G1。</li>
</ul>
<h3 id="垃圾收集器与分代之间的关系："><a href="#垃圾收集器与分代之间的关系：" class="headerlink" title="垃圾收集器与分代之间的关系："></a>垃圾收集器与分代之间的关系：</h3><ul>
<li>新生代收集器：Serial、ParNew、Parallel Scavenge。</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS。</li>
<li>整堆收集器：G1。</li>
</ul>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image-20200713093757644.png" alt></p>
<h3 id="垃圾收集器的组合关系："><a href="#垃圾收集器的组合关系：" class="headerlink" title="垃圾收集器的组合关系："></a>垃圾收集器的组合关系：</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image-20200713094745366.png" alt></p>
<ul>
<li><p>Serial + Serial Old，Serial + CMS</p>
</li>
<li><p>ParNew + Serial Old，ParNew + CMS</p>
</li>
<li><p>Parallel Scavenge + Serial Old，Parallel Scavenge + Parallel Old。</p>
</li>
<li><p>其中 Serial Old 还会作为 CMS 出现 “Concurrent Mode Failure” 失败的后备预案。</p>
</li>
<li><p>红色虚线：在 JDK 8 时将 Serial + CMS，ParNew + Serial Old 声明为废弃，并在 JDK9 中彻底取消了对这些组合的支持。</p>
</li>
<li><p>绿色虚线：在 JDK14 中，弃用 Parallel Scavenge + Serial Old 的组合。</p>
</li>
<li><p>青色虚线：在 JDK14 中，删除 CMS 垃圾收集器。</p>
</li>
</ul>
<h3 id="查看默认收集器"><a href="#查看默认收集器" class="headerlink" title="查看默认收集器"></a>查看默认收集器</h3><p>Java -XX:+PrintCommandLineFlags -version</p>
<p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image5.png" alt></p>
<h2 id="19-遇到过哪些-OOM-问题"><a href="#19-遇到过哪些-OOM-问题" class="headerlink" title="19 遇到过哪些 OOM 问题"></a>19 遇到过哪些 OOM 问题</h2><ul>
<li>内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 </li>
<li>内存溢出out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</li>
</ul>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ol>
<li><p>一般首先考虑内存泄露/内存溢出的情况，需要配置 JVM 参数输出 dump 文件。</p>
<p> -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof。</p>
<p> -XX:+HeapDumpOnOutOfMemoryError 设置当首次遭遇内存溢出时导出此时堆中相关信息。</p>
<p> -XX:HeapDumpPath=/tmp/heapdump.hprof 指定导出堆信息时的路径或文件名。</p>
</li>
<li><p>接着通过内存映像分析工具（如 JProfiler，MAT）对 dump 出来的堆转储快照进行分析，确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</p>
</li>
<li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GCRoots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GCRoots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
</li>
<li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
</li>
</ol>
<h3 id="溢出场景"><a href="#溢出场景" class="headerlink" title="溢出场景"></a>溢出场景</h3><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>如突发高峰期时，内存存活对象使用空间的量超出最大堆，并且无法回收。</p>
<ul>
<li>小公司没这个可能，可以说是某个时间段导出特大报表导致。</li>
<li>想下项目有哪些垃圾代码使用了大内存耗时操作，且长时间不能被回收，什么全表查数据计算，循环做 String 拼接操作等等。</li>
</ul>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>重新不在使用的对象仍然存在引用导致无法回收，随着时间推移，泄漏内存对象占用了所有可用堆。</p>
<ul>
<li>比如 dubbo 泛化调用没缓存 ReferenceConfig 实例导致了内存泄漏。</li>
</ul>
<h3 id="OOM-原因"><a href="#OOM-原因" class="headerlink" title="OOM 原因"></a>OOM 原因</h3><h4 id="Java-heap-space（应用尝试从堆申请一个区域时，堆没有可分配的空间）"><a href="#Java-heap-space（应用尝试从堆申请一个区域时，堆没有可分配的空间）" class="headerlink" title="Java heap space（应用尝试从堆申请一个区域时，堆没有可分配的空间）"></a>Java heap space（应用尝试从堆申请一个区域时，堆没有可分配的空间）</h4><p>原因：内存泄漏、内存溢出</p>
<h4 id="GC-overhead-limit-exceeded（超过-98-的时间在-GC，且回收了不到-2-的堆内存）"><a href="#GC-overhead-limit-exceeded（超过-98-的时间在-GC，且回收了不到-2-的堆内存）" class="headerlink" title="GC overhead limit exceeded（超过 98% 的时间在 GC，且回收了不到 2% 的堆内存）"></a>GC overhead limit exceeded（超过 98% 的时间在 GC，且回收了不到 2% 的堆内存）</h4><p>原因：内存泄漏、内存溢出</p>
<h4 id="unable-to-create-new-native-thread（无法创建新的本地线程）"><a href="#unable-to-create-new-native-thread（无法创建新的本地线程）" class="headerlink" title="unable to create new native thread（无法创建新的本地线程）"></a>unable to create new native thread（无法创建新的本地线程）</h4><ul>
<li><p>原因</p>
<ul>
<li>系统内存耗尽，无法为新线程分配内存</li>
<li>创建线程数超过了操作系统的限制</li>
</ul>
</li>
<li><p>解决</p>
<ul>
<li>排查应用线程数：通过 jstack 排查应用哪个地方创建了过多的线程。</li>
<li>调整操作系统线程数阈值：通过 ulimit -u 查看操作系统的最大进程数是否需要修改。</li>
<li>减小堆内存：JVM 是否占满了系统总内存，导致系统线程没有足够的内存分配，如果是这种，就考虑降低堆内存，否则就增加系统内存。</li>
</ul>
</li>
</ul>
<h4 id="Metaspace（元空间不足，加载到内存中的-class-数量太多或者体积太大）"><a href="#Metaspace（元空间不足，加载到内存中的-class-数量太多或者体积太大）" class="headerlink" title="Metaspace（元空间不足，加载到内存中的 class 数量太多或者体积太大）"></a>Metaspace（元空间不足，加载到内存中的 class 数量太多或者体积太大）</h4><p>解决：修改 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize。</p>
<h4 id="Direct-buffer-memory（直接内存不足，通常是-NIO-引起的）"><a href="#Direct-buffer-memory（直接内存不足，通常是-NIO-引起的）" class="headerlink" title="Direct buffer memory（直接内存不足，通常是 NIO 引起的）"></a>Direct buffer memory（直接内存不足，通常是 NIO 引起的）</h4><ul>
<li><p>原因</p>
<p>  ByteBuffer.allocteDirect(capability) 是直接分配 OS 本地内存，如何不断分配本地内存，堆内存很少使用，那么 JVM 就不需要执行 GC，DirectByteBuffer 就不会被回收，这时候堆内存充足，但本地内存很快就给耗光了。</p>
</li>
<li><p>解决</p>
<p>  加大 -XX:MaxDirectMemorySize。</p>
</li>
</ul>
<h4 id="Requested-array-size-exceeds-VM-limit（数组太大，超过了平台限制值）"><a href="#Requested-array-size-exceeds-VM-limit（数组太大，超过了平台限制值）" class="headerlink" title="Requested array size exceeds VM limit（数组太大，超过了平台限制值）"></a>Requested array size exceeds VM limit（数组太大，超过了平台限制值）</h4><p>解决：减小数组长度，拆分大数组等。</p>
<h4 id="Out-of-swap-space（交换空间空间不足，表明请求分配内存的操作失败了）"><a href="#Out-of-swap-space（交换空间空间不足，表明请求分配内存的操作失败了）" class="headerlink" title="Out of swap space（交换空间空间不足，表明请求分配内存的操作失败了）"></a>Out of swap space（交换空间空间不足，表明请求分配内存的操作失败了）</h4><p>解决：java 进程使用了虚拟内存才会发生，这时得增加虚拟内存的大小。</p>
<h3 id="堆是分配对象的唯一选择"><a href="#堆是分配对象的唯一选择" class="headerlink" title="堆是分配对象的唯一选择"></a>堆是分配对象的唯一选择</h3><p>不一定，在 JDK 1.7 版本之后，HotSpot 中默认就已经开启了逃逸分析。</p>
<p>如果经过逃逸分析后发现，一个对象没有逃逸出方法的话，就会被优化成栈上分配，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<h2 id="20-分析-GC-日志"><a href="#20-分析-GC-日志" class="headerlink" title="20 分析 GC 日志"></a>20 分析 GC 日志</h2><h3 id="Young-GC-参数图"><a href="#Young-GC-参数图" class="headerlink" title="Young GC 参数图"></a>Young GC 参数图</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image-20200714082555688.png" alt></p>
<h3 id="Full-GC-参数图"><a href="#Full-GC-参数图" class="headerlink" title="Full GC 参数图"></a>Full GC 参数图</h3><p><img src="/2021/05/20/2021-05-20-chong-xue-jvm/image-20200714082714690.png" alt></p>
<h2 id="21-JVM参数"><a href="#21-JVM参数" class="headerlink" title="21 JVM参数"></a>21 JVM参数</h2><h3 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h3><p>标准参数以-开头，比较稳定，后续版本基本不会变化。</p>
<p>在控制台输入java -help，可以看到所有的标准参数</p>
<h3 id="X参数"><a href="#X参数" class="headerlink" title="-X参数"></a>-X参数</h3><p>非标准化参数，功能比较稳定，后续版本可能会变更，以-X开头</p>
<p>在控制台输入java -X，可以看到相关参数</p>
<ul>
<li>-Xinit：禁用JIT，所有的字节码都被解释执行，速度最慢</li>
<li>-Xcomp，所有的字节码第一次就被编译，然后再执行</li>
<li>-Xmixed，混合模式，默认，让JIT根据程序运行情况，动态编译</li>
<li>-Xms，初始化java堆的大小，相当于-XX:InitialHeapSize，如-Xms2g</li>
<li>-Xmx，设置最大java堆大小，相当于-XX:MaxHeapSize</li>
<li>-Xss，设置java线程栈的大小，相当于-XX:ThreadStackSize</li>
</ul>
<h3 id="XX参数"><a href="#XX参数" class="headerlink" title="-XX参数"></a>-XX参数</h3><p>使用最多的参数类型，比较不稳定，以-XX开头</p>
<p>-XX参数分为Boolean类型和非Boolean类型</p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>-XX:+，表示开启option</p>
<p>-XX:-，表示关闭option，有些参数是默认开启的，可以通过-进行关闭</p>
<p>如，-XX:+UseParallelGC，-XX:+UseAdaptiveSizePolicy</p>
<h4 id="非Boolean"><a href="#非Boolean" class="headerlink" title="非Boolean"></a>非Boolean</h4><p>非Boolean，分为数值类型和非数值类型，如果是数值类型，就进行赋值</p>
<p>-XX:=<option>=<string></string></option></p>
<p>如，-XX:NewRatio=2，-XX:NewSize=2M</p>
<p>如果是非数值类型，则填写对应的值</p>
<p>-XX:=<option>=<string></string></option></p>
<p>如，-XX:HeapDumpPath=/xxx/xxx/duml.hprof</p>
<h4 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h4><p>-XX:+PrintFlagsFinal，输出所有参数的名称和默认值，默认不包括诊断和实验的参数</p>
<h2 id="生产配置垃圾回收器"><a href="#生产配置垃圾回收器" class="headerlink" title="生产配置垃圾回收器"></a>生产配置垃圾回收器</h2><p>JDK8默认的是Parallel Scavenge（复制） + Parallel Old（标记-整理）。</p>
<p>但我们的是金融支付系统，如果垃圾回收的可能会造成用户线程较长停顿，进而可能造成一些订单超时。</p>
<p>所以我们线上配置的是ParNew(复制) + CMS(标志清除)。CMS是并发收集器，可以进一步缩短回收的停顿时间。</p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li>
</ul>
<h2 id="开发中遇到OOM问题"><a href="#开发中遇到OOM问题" class="headerlink" title="开发中遇到OOM问题"></a>开发中遇到OOM问题</h2><ol>
<li>获取dump文件；</li>
<li>用Eclipse Memory Analyzer(mat)导入dump文件分析；</li>
<li>发现多数据源中某个链接信息错误，导致不断重连；</li>
<li>修改代码或链接信息。</li>
</ol>
<h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 CMS 和 G1？</li>
<li>JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？可以说用的 JDK8，Parallel Scavenge（复制） + Parallel Old（标记-整理）。</li>
<li>G1 回收器讲下回收过程？GC 是什么？为什么要有 GC？</li>
<li>CMS 收集器与 G1 收集器的特点？</li>
<li>CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
<li>JDK8 的内存分代改进？JVM 内存分哪几个区，每个区的作用是什么？</li>
<li>JVM 内存分布/内存结构？</li>
<li>栈和堆的区别？</li>
<li>堆的结构？</li>
<li>为什么两个 Survivor 区？ </li>
<li>Eden 和 Survior 的比例分配？</li>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ul>
<h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc() 和 Runtime.gc() 会做什么事情？</li>
<li>Java GC 机制？GC Roots 有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程。</li>
<li>CMS 回收停顿了几次，为什么要停顿两次？</li>
<li>什么时候对象会进入老年代？</li>
</ul>
<h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul>
<li>说一下 JVM 内存模型吧，有哪些区？分别干什么的？</li>
<li>说一下 GC 算法，分代回收说下。</li>
</ul>
<h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下 CMS 和 G1。 </li>
</ul>
<h3 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h3><ul>
<li>JVM 内存分区，为什么要有新生代和老年代？</li>
</ul>
<h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><ul>
<li>JVM 的永久代中会发生垃圾回收吗？</li>
</ul>
<h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ul>
<li>Java 的垃圾回收器都有哪些，说下 G1 的应用场景，平时你是如何搭配使用垃圾回收器的？</li>
</ul>

            </div>
            <hr>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://adbo.gitee.io" rel="external nofollow noreferrer">Adbo</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://adbo.gitee.io/2021/05/20/2021-05-20-chong-xue-jvm/">http://adbo.gitee.io/2021/05/20/2021-05-20-chong-xue-jvm/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://adbo.gitee.io" target="_blank">Adbo</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JVM/">
                                    <span class="chip bg-color">JVM</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">充点钱我更猛</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '9150c7c4b90b14e0cd58',
        clientSecret: '9666f231bec8dfe9335833e3684d57d2fcf8da6b',
        repo: 'gitalk',
        owner: 'adbbo',
        admin: "adbbo",
        id: '2021-05-20T23-45-46',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/05/25/2021-05-25-chong-xue-mq/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="消息队列">
                        
                        <span class="card-title">消息队列</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            MQ思路清晰版~
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-05-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/review/" class="post-category">
                                    review
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/消息队列/">
                        <span class="chip bg-color">消息队列</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/05/13/2021-5-13-shou-xie-lru/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="手写LRU">
                        
                        <span class="card-title">手写LRU</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            手写LRU算法
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/复习PLUS/" class="post-category">
                                    复习PLUS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Redis/">
                        <span class="chip bg-color">Redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="http://adbo.gitee.io" target="_blank">Adbo</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/adbbo" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1309338083@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1309338083" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1309338083" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
